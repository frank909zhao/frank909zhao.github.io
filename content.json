[{"title":"","date":"2017-02-12T14:45:30.591Z","path":"2017/02/12/一看你就懂，超详细Java中的ClassLoader讲解/","text":"title: 一看你就懂，超详细Java中的ClassLoader讲解date: 2017-02-12 22:45:30 tags: ITClassLoader翻译过来就是类加载器，普通的java开发者其实用到的不多，但对于某些框架开发者来说却非常常见。理解ClassLoader的加载机制，也有利于我们编写出更高效的代码。ClassLoader的具体作用就是将class文件加载到jvm虚拟机中去，程序就可以正确运行了。但是，jvm启动的时候，并不会一次性加载所有的class文件，而是根据需要去动态加载。想想也是的，一次性加载那么多jar包那么多class，那内存不崩溃。本文的目的也是学习ClassLoader这种加载机制。 备注：本文篇幅比较长，但内容简单，大家不要恐慌，安静地耐心翻阅就是 Class文件的认识我们都知道在Java中程序是运行在虚拟机中，我们平常用文本编辑器或者是IDE编写的程序都是.java格式的文件，这是最基础的源码，但这类文件是不能直接运行的。如我们编写一个简单的程序HelloWorld.java123456public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println(\"Hello world!\"); &#125;&#125; 如图：然后，我们需要在命令行中进行java文件的编译1javac HelloWorld.java 可以看到目录下生成了.class文件 我们再从命令行中执行命令：1java HelloWorld 上面是基本代码示例，是所有入门JAVA语言时都学过的东西，这里重新拿出来是想让大家将焦点回到class文件上，class文件是字节码格式文件，java虚拟机并不能直接识别我们平常编写的.java源文件，所以需要javac这个命令转换成.class文件。另外，如果用C或者PYTHON编写的程序正确转换成.class文件后，java虚拟机也是可以识别运行的。更多信息大家可以参考这篇。 了解了.class文件后，我们再来思考下，我们平常在Eclipse中编写的java程序是如何运行的，也就是我们自己编写的各种类是如何被加载到jvm(java虚拟机)中去的。 你还记得java环境变量吗？初学java的时候，最害怕的就是下载JDK后要配置环境变量了，关键是当时不理解，所以战战兢兢地照着书籍上或者是网络上的介绍进行操作。然后下次再弄的时候，又忘记了而且是必忘。当时，心里的想法很气愤的，想着是–这东西一点也不人性化，为什么非要自己配置环境变量呢？太不照顾菜鸟和新手了，很多菜鸟就是因为卡在环境变量的配置上，遭受了太多的挫败感。 因为我是在Windows下编程的，所以只讲Window平台上的环境变量，主要有3个：JAVA_HOME、PATH、CLASSPATH。 JAVA_HOME指的是你JDK安装的位置，一般默认安装在C盘，如1C:\\Program Files\\Java\\jdk1.8.0_91 PATH将程序路径包含在PATH当中后，在命令行窗口就可以直接键入它的名字了，而不再需要键入它的全路径,比如上面代码中我用的到123一般的 ``` cmdPATH=%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;%PATH%; 也就是在原来的PATH路径上添加JDK目录下的bin目录和jre目录的bin. CLASSPATH1CLASSPATH=.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar 一看就是指向jar包路径。需要注意的是前面的.```代表当前目录。 12345678910111213## 环境变量的设置与查看设置可以右击我的电脑，然后点击属性，再点击高级，然后点击环境变量，具体不明白的自行查阅文档。 查看的话可以打开命令行窗口``` cmdecho %JAVA_HOME%echo %PATH%echo %CLASSPATH% 好了，扯远了，知道了环境变量，特别是CLASSPATH时，我们进入今天的主题Classloader. JAVA类加载流程Java语言系统自带有三个类加载器: Bootstrap ClassLoader 最顶层的加载类，主要加载核心类库，%JRE_HOME%\\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如-Xbootclasspath/a:path ```被指定的文件追加到默认的bootstrap路径中。我们可以打开我的电脑，在上面的目录下查看，看看这些jar包是不是存在于这个目录。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566- **Extention ClassLoader** 扩展的类加载器，加载目录%JRE_HOME%\\lib\\ext目录下的jar包和class文件。还可以加载```-D java.ext.dirs```选项指定的目录。- **Appclass Loader也称为SystemAppClass** 加载当前应用的classpath的所有类。 我们上面简单介绍了3个ClassLoader。说明了它们加载的路径。并且还提到了```-Xbootclasspath```和```-D java.ext.dirs```这两个虚拟机参数选项。 ## 加载顺序？我们看到了系统的3个类加载器，但我们可能不知道具体哪个先行呢？ 我可以先告诉你答案1. Bootstrap CLassloder 2. Extention ClassLoader 3. AppClassLoader 为了更好的理解，我们可以查看源码。 看[sun.misc.Launcher](http://www.grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/misc/Launcher.java),它是一个java虚拟机的入口应用。 ``` javapublic class Launcher &#123; private static Launcher launcher = new Launcher(); private static String bootClassPath = System.getProperty(\"sun.boot.class.path\"); public static Launcher getLauncher() &#123; return launcher; &#125; private ClassLoader loader; public Launcher() &#123; // Create the extension class loader ClassLoader extcl; try &#123; extcl = ExtClassLoader.getExtClassLoader(); &#125; catch (IOException e) &#123; throw new InternalError( \"Could not create extension class loader\", e); &#125; // Now create the class loader to use to launch the application try &#123; loader = AppClassLoader.getAppClassLoader(extcl); &#125; catch (IOException e) &#123; throw new InternalError( \"Could not create application class loader\", e); &#125; //设置AppClassLoader为线程上下文类加载器，这个文章后面部分讲解 Thread.currentThread().setContextClassLoader(loader); &#125; /* * Returns the class loader used to launch the main application. */ public ClassLoader getClassLoader() &#123; return loader; &#125; /* * The class loader used for loading installed extensions. */ static class ExtClassLoader extends URLClassLoader &#123;&#125;/** * The class loader used for loading from java.class.path. * runs in a restricted security context. */ static class AppClassLoader extends URLClassLoader &#123;&#125; &#125; 源码有精简，我们可以得到相关的信息。 Launcher初始化了ExtClassLoader和AppClassLoader。 Launcher中并没有看见BootstrapClassLoader，但通过1234我们可以先代码测试一下```sun.boot.class.path```是什么内容。 ``` javaSystem.out.println(System.getProperty(&quot;sun.boot.class.path&quot;)); 得到的结果是：12345678C:\\Program Files\\Java\\jre1.8.0_91\\lib\\resources.jar;C:\\Program Files\\Java\\jre1.8.0_91\\lib\\rt.jar;C:\\Program Files\\Java\\jre1.8.0_91\\lib\\sunrsasign.jar;C:\\Program Files\\Java\\jre1.8.0_91\\lib\\jsse.jar;C:\\Program Files\\Java\\jre1.8.0_91\\lib\\jce.jar;C:\\Program Files\\Java\\jre1.8.0_91\\lib\\charsets.jar;C:\\Program Files\\Java\\jre1.8.0_91\\lib\\jfr.jar;C:\\Program Files\\Java\\jre1.8.0_91\\classes 可以看到，这些全是JRE目录下的jar包或者是class文件。 ExtClassLoader源码如果你有足够的好奇心，你应该会对它的源码感兴趣1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* * The class loader used for loading installed extensions. */ static class ExtClassLoader extends URLClassLoader &#123; static &#123; ClassLoader.registerAsParallelCapable(); &#125; /** * create an ExtClassLoader. The ExtClassLoader is created * within a context that limits which files it can read */ public static ExtClassLoader getExtClassLoader() throws IOException &#123; final File[] dirs = getExtDirs(); try &#123; // Prior implementations of this doPrivileged() block supplied // aa synthesized ACC via a call to the private method // ExtClassLoader.getContext(). return AccessController.doPrivileged( new PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123; public ExtClassLoader run() throws IOException &#123; int len = dirs.length; for (int i = 0; i &lt; len; i++) &#123; MetaIndex.registerDirectory(dirs[i]); &#125; return new ExtClassLoader(dirs); &#125; &#125;); &#125; catch (java.security.PrivilegedActionException e) &#123; throw (IOException) e.getException(); &#125; &#125; private static File[] getExtDirs() &#123; String s = System.getProperty(\"java.ext.dirs\"); File[] dirs; if (s != null) &#123; StringTokenizer st = new StringTokenizer(s, File.pathSeparator); int count = st.countTokens(); dirs = new File[count]; for (int i = 0; i &lt; count; i++) &#123; dirs[i] = new File(st.nextToken()); &#125; &#125; else &#123; dirs = new File[0]; &#125; return dirs; &#125; ...... &#125; 我们先前的内容有说过，可以指定java.ext.dirs```参数来添加和改变ExtClassLoader的加载路径。这里我们通过可以编写测试代码。 12``` java System.out.println(System.getProperty(&quot;java.ext.dirs&quot;)); 结果如下：1C:\\Program Files\\Java\\jre1.8.0_91\\lib\\ext;C:\\Windows\\Sun\\Java\\lib\\ext AppClassLoader源码1234567891011121314151617181920212223242526/** * The class loader used for loading from java.class.path. * runs in a restricted security context. */ static class AppClassLoader extends URLClassLoader &#123; public static ClassLoader getAppClassLoader(final ClassLoader extcl) throws IOException &#123; final String s = System.getProperty(\"java.class.path\"); final File[] path = (s == null) ? new File[0] : getClassPath(s); return AccessController.doPrivileged( new PrivilegedAction&lt;AppClassLoader&gt;() &#123; public AppClassLoader run() &#123; URL[] urls = (s == null) ? new URL[0] : pathToURLs(path); return new AppClassLoader(urls, extcl); &#125; &#125;); &#125; ...... &#125; 可以看到AppClassLoader加载的就是12``` javaSystem.out.println(System.getProperty(&quot;java.class.path&quot;)); 结果：1D:\\workspace\\ClassLoaderDemo\\bin 这个路径其实就是当前java工程目录bin，里面存放的是编译生成的class文件。 好了，自此我们已经知道了BootstrapClassLoader、ExtClassLoader、AppClassLoader实际是查阅相应的环境属性123456接下来我们探讨它们的加载顺序，我们先用Eclipse建立一个java工程。![这里写图片描述](http://img.blog.csdn.net/20170210192102102?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)然后创建一个```Test.java```文件。``` javapublic class Test&#123;&#125; 然后，编写一个ClassLoaderTest.java文件。12345678910111213public class ClassLoaderTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ClassLoader cl = Test.class.getClassLoader(); System.out.println(\"ClassLoader is:\"+cl.toString()); &#125;&#125; 我们获取到了Test.class文件的类加载器，然后打印出来。结果是：1ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93 也就是说明Test.class文件是由AppClassLoader加载的。 这个Test类是我们自己编写的，那么int.class或者是String.class的加载是由谁完成的呢？我们可以在代码中尝试12345678910111213141516public class ClassLoaderTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ClassLoader cl = Test.class.getClassLoader(); System.out.println(\"ClassLoader is:\"+cl.toString()); cl = int.class.getClassLoader(); System.out.println(\"ClassLoader is:\"+cl.toString()); &#125;&#125; 运行一下，却报错了123ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93Exception in thread &quot;main&quot; java.lang.NullPointerException at ClassLoaderTest.main(ClassLoaderTest.java:15) 提示的是空指针，意思是int.class这类基础类没有类加载器加载？ 当然不是！int.class是由Bootstrap ClassLoader加载的。要想弄明白这些，我们首先得知道一个前提。 每个类加载器都有一个父加载器每个类加载器都有一个父加载器，比如加载Test.class是由AppClassLoader完成，那么AppClassLoader也有一个父加载器，怎么样获取呢？很简单，通过getParent方法。比如代码可以这样编写：1234ClassLoader cl = Test.class.getClassLoader(); System.out.println(\"ClassLoader is:\"+cl.toString());System.out.println(\"ClassLoader\\'s parent is:\"+cl.getParent().toString()); 运行结果如下：12ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93ClassLoader&apos;s parent is:sun.misc.Launcher$ExtClassLoader@15db9742 这个说明，AppClassLoader的父加载器是ExtClassLoader。那么ExtClassLoader的父加载器又是谁呢？123System.out.println(\"ClassLoader is:\"+cl.toString());System.out.println(\"ClassLoader\\'s parent is:\"+cl.getParent().toString());System.out.println(\"ClassLoader\\'s grand father is:\"+cl.getParent().getParent().toString()); 运行如果：1234ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93Exception in thread &quot;main&quot; ClassLoader&apos;s parent is:sun.misc.Launcher$ExtClassLoader@15db9742java.lang.NullPointerException at ClassLoaderTest.main(ClassLoaderTest.java:13) 又是一个空指针异常，这表明ExtClassLoader也没有父加载器。那么，为什么标题又是每一个加载器都有一个父加载器呢？这不矛盾吗？为了解释这一点，我们还需要看下面的一个基础前提。 父加载器不是父类我们先前已经粘贴了ExtClassLoader和AppClassLoader的代码。12static class ExtClassLoader extends URLClassLoader &#123;&#125;static class AppClassLoader extends URLClassLoader &#123;&#125; 可以看见ExtClassLoader和AppClassLoader同样继承自URLClassLoader，但上面一小节代码中，为什么调用AppClassLoader的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 先上一张类的继承关系图 ![这里写图片描述](http://img.blog.csdn.net/20170211112754197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) URLClassLoader的源码中并没有找到```getParent()```方法。这个方法在ClassLoader.java中。 ``` javapublic abstract class ClassLoader &#123;// The parent class loader for delegation// Note: VM hardcoded the offset of this field, thus all new fields// must be added *after* it.private final ClassLoader parent;// The class loader for the system // @GuardedBy(&quot;ClassLoader.class&quot;)private static ClassLoader scl;private ClassLoader(Void unused, ClassLoader parent) &#123; this.parent = parent; ...&#125;protected ClassLoader(ClassLoader parent) &#123; this(checkCreateClassLoader(), parent);&#125;protected ClassLoader() &#123; this(checkCreateClassLoader(), getSystemClassLoader());&#125;public final ClassLoader getParent() &#123; if (parent == null) return null; return parent;&#125;public static ClassLoader getSystemClassLoader() &#123; initSystemClassLoader(); if (scl == null) &#123; return null; &#125; return scl;&#125;private static synchronized void initSystemClassLoader() &#123; if (!sclSet) &#123; if (scl != null) throw new IllegalStateException(&quot;recursive invocation&quot;); sun.misc.Launcher l = sun.misc.Launcher.getLauncher(); if (l != null) &#123; Throwable oops = null; //通过Launcher获取ClassLoader scl = l.getClassLoader(); try &#123; scl = AccessController.doPrivileged( new SystemClassLoaderAction(scl)); &#125; catch (PrivilegedActionException pae) &#123; oops = pae.getCause(); if (oops instanceof InvocationTargetException) &#123; oops = oops.getCause(); &#125; &#125; if (oops != null) &#123; if (oops instanceof Error) &#123; throw (Error) oops; &#125; else &#123; // wrap the exception throw new Error(oops); &#125; &#125; &#125; sclSet = true; &#125;&#125;&#125; 我们可以看到12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576771. 由外部类创建ClassLoader时直接指定一个ClassLoader为parent。 2. 由```getSystemClassLoader()```方法生成，也就是在sun.misc.Laucher通过```getClassLoader()```获取，也就是AppClassLoader。直白的说，一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。 我们主要研究的是ExtClassLoader与AppClassLoader的parent的来源，正好它们与Launcher类有关，我们上面已经粘贴过Launcher的部分代码。 ``` java public class Launcher &#123; private static URLStreamHandlerFactory factory = new Factory(); private static Launcher launcher = new Launcher(); private static String bootClassPath = System.getProperty(&quot;sun.boot.class.path&quot;); public static Launcher getLauncher() &#123; return launcher; &#125; private ClassLoader loader; public Launcher() &#123; // Create the extension class loader ClassLoader extcl; try &#123; extcl = ExtClassLoader.getExtClassLoader(); &#125; catch (IOException e) &#123; throw new InternalError( &quot;Could not create extension class loader&quot;, e); &#125; // Now create the class loader to use to launch the application try &#123; //将ExtClassLoader对象实例传递进去 loader = AppClassLoader.getAppClassLoader(extcl); &#125; catch (IOException e) &#123; throw new InternalError( &quot;Could not create application class loader&quot;, e); &#125;public ClassLoader getClassLoader() &#123; return loader; &#125;static class ExtClassLoader extends URLClassLoader &#123; /** * create an ExtClassLoader. The ExtClassLoader is created * within a context that limits which files it can read */ public static ExtClassLoader getExtClassLoader() throws IOException &#123; final File[] dirs = getExtDirs(); try &#123; // Prior implementations of this doPrivileged() block supplied // aa synthesized ACC via a call to the private method // ExtClassLoader.getContext(). return AccessController.doPrivileged( new PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123; public ExtClassLoader run() throws IOException &#123; //ExtClassLoader在这里创建 return new ExtClassLoader(dirs); &#125; &#125;); &#125; catch (java.security.PrivilegedActionException e) &#123; throw (IOException) e.getException(); &#125; &#125; /* * Creates a new ExtClassLoader for the specified directories. */ public ExtClassLoader(File[] dirs) throws IOException &#123; super(getExtURLs(dirs), null, factory); &#125; &#125; &#125; &#125; 我们需要注意的是12345ClassLoader extcl; extcl = ExtClassLoader.getExtClassLoader();loader = AppClassLoader.getAppClassLoader(extcl); 代码已经说明了问题AppClassLoader的parent是一个ExtClassLoader实例。 ExtClassLoader并没有直接找到对parent的赋值。它调用了它的父类也就是URLClassLoder的构造方法并传递了3个参数。123public ExtClassLoader(File[] dirs) throws IOException &#123; super(getExtURLs(dirs), null, factory); &#125; 对应的代码1234public URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory) &#123; super(parent);&#125; 答案已经很明了了，ExtClassLoader的parent为null。 上面张贴这么多代码也是为了说明AppClassLoader的parent是ExtClassLoader，ExtClassLoader的parent是null。这符合我们之前编写的测试代码。 不过，细心的同学发现，还是有疑问的我们只看到ExtClassLoader和AppClassLoader的创建，那么BootstrapClassLoader呢？ 还有，ExtClassLoader的父加载器为null,但是Bootstrap CLassLoader却可以当成它的父加载器这又是为何呢？ 我们继续往下进行。 Bootstrap ClassLoader是由C++编写的。Bootstrap ClassLoader是由C/C++编写的，它本身是虚拟机的一部分，所以它并不是一个JAVA类，也就是无法在java代码中获取它的引用，JVM启动时通过Bootstrap类加载器加载rt.jar等核心jar包中的class文件，之前的int.class,String.class都是由它加载。然后呢，我们前面已经分析了，JVM初始化sun.misc.Launcher并创建Extension ClassLoader和AppClassLoader实例。并将ExtClassLoader设置为AppClassLoader的父加载器。Bootstrap没有父加载器，但是它却可以作用一个ClassLoader的父加载器。比如ExtClassLoader。这也可以解释之前通过ExtClassLoader的getParent方法获取为Null的现象。具体是什么原因，很快就知道答案了。 双亲委托双亲委托。我们终于来到了这一步了。一个类加载器查找class和resource时，是通过“委托模式”进行的，它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap classloader找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。整个流程可以如下图所示：这张图是用时序图画出来的，不过画出来的结果我却自己都觉得不理想。 大家可以看到2根箭头，蓝色的代表类加载器向上委托的方向，如果当前的类加载器没有查询到这个class对象已经加载就请求父加载器（不一定是父类）进行操作，然后以此类推。直到Bootstrap ClassLoader。如果Bootstrap ClassLoader也没有加载过此class实例，那么它就会从它指定的路径中去查找，如果查找成功则返回，如果没有查找成功则交给子类加载器，也就是ExtClassLoader,这样类似操作直到终点，也就是我上图中的红色箭头示例。用序列描述一下： 一个AppClassLoader查找资源时，先看看缓存是否有，缓存有从缓存中获取，否则委托给父加载器。 递归，重复第1部的操作。 如果ExtClassLoader也没有加载过，则由Bootstrap ClassLoader出面，它首先查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是123456789101112131415161718194. Bootstrap ClassLoader如果没有查找成功，则ExtClassLoader自己在```java.ext.dirs```路径中去查找，查找成功就返回，查找不成功，再向下让子加载器找。 5. ExtClassLoader查找不成功，AppClassLoader就自己查找，在```java.class.path```路径下查找。找到就返回。如果没有找到就让子类找，如果没有子类会怎么样？抛出各种异常。 上面的序列，详细说明了双亲委托的加载流程。**我们可以发现委托是从下向上，然后具体查找过程却是自上至下。**我说过上面用时序图画的让自己不满意，现在用框图，最原始的方法再画一次。 ![这里写图片描述](http://img.blog.csdn.net/20170211135054825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)上面已经详细介绍了加载过程，但具体为什么是这样加载，我们还需要了解几个个重要的方法loadClass()、findLoadedClass()、findClass()、defineClass()。## 重要方法### loadClass()JDK文档中是这样写的，通过指定的全限定类名加载class，它通过同名的loadClass(String,boolean)方法。``` javaprotected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123;&#125; 上面是方法原型，一般实现这个方法的步骤是 执行123456789101112131415161718192021222324252627282930313233343536373839404142434445462. 执行父加载器的```loadClass```方法。如果父加载器为null，则jvm内置的加载器去替代，也就是Bootstrap ClassLoader。这也解释了ExtClassLoader的parent为null,但仍然说Bootstrap ClassLoader是它的父加载器。 3. 如果向上委托父加载器没有加载成功，则通过```findClass(String)```查找。 如果class在上面的步骤中找到了，参数resolve又是true的话，那么```loadClass()```又会调用```resolveClass(Class)```这个方法来生成最终的Class对象。 我们可以从源代码看出这个步骤。 ``` javaprotected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // 首先，检测是否已经加载 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //父加载器不为空则调用父加载器的loadClass c = parent.loadClass(name, false); &#125; else &#123; //父加载器为空则调用Bootstrap Classloader c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); //父加载器没有找到，则调用findclass c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; //调用resolveClass() resolveClass(c); &#125; return c; &#125; &#125; 代码解释了双亲委托。 另外，要注意的是如果要编写一个classLoader的子类，也就是自定义一个classloader，建议覆盖123456789另外``` javaif (parent != null) &#123; //父加载器不为空则调用父加载器的loadClass c = parent.loadClass(name, false);&#125; else &#123; //父加载器为空则调用Bootstrap Classloader c = findBootstrapClassOrNull(name);&#125; 前面说过ExtClassLoader的parent为null，所以它向上委托时，系统会为它指定Bootstrap ClassLoader。 自定义ClassLoader不知道大家有没有发现，不管是Bootstrap ClassLoader还是ExtClassLoader等，这些类加载器都只是加载指定的目录下的jar包或者资源。如果在某种情况下，我们需要动态加载一些东西呢？比如从D盘某个文件夹加载一个class文件，或者从网络上下载class主内容然后再进行加载，这样可以吗？ 如果要这样做的话，需要我们自定义一个classloader。 自定义步骤 编写一个类继承自ClassLoader抽象类。 复写它的123456789101112131415161718192021222324252627283. 在```findClass()```方法中调用```defineClass()```。 ### defineClass()这个方法在编写自定义classloader的时候非常重要，它能将class二进制内容转换成Class对象，如果不符合要求的会抛出各种异常。 ## 注意点：**一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。 **上面说的是，如果自定义一个ClassLoader，默认的parent父加载器是AppClassLoader，因为这样就能够保证它能访问系统内置加载器加载成功的class文件。## 自定义ClassLoader示例之DiskClassLoader。假设我们需要一个自定义的classloader,默认加载路径为```D:\\lib```下的jar包和资源。 我们写编写一个测试用的类文件，Test.java#### Test.java``` javapackage com.frank.test;public class Test &#123; public void say()&#123; System.out.println(&quot;Say Hello&quot;); &#125;&#125; 然后将它编译过年class文件Test.class放到123#### DiskClassLoader 我们编写DiskClassLoader的代码。 import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException; public class DiskClassLoader extends ClassLoader { private String mLibPath; public DiskClassLoader(String path) { // TODO Auto-generated constructor stub mLibPath = path; } @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { // TODO Auto-generated method stub String fileName = getFileName(name); File file = new File(mLibPath,fileName); try { FileInputStream is = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int len = 0; try { while ((len = is.read()) != -1) { bos.write(len); } } catch (IOException e) { e.printStackTrace(); } byte[] data = bos.toByteArray(); is.close(); bos.close(); return defineClass(name,data,0,data.length); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } return super.findClass(name); } //获取要加载 的class文件名 private String getFileName(String name) { // TODO Auto-generated method stub int index = name.lastIndexOf(&apos;.&apos;); if(index == -1){ return name+&quot;.class&quot;; }else{ return name.substring(index)+&quot;.class&quot;; } } }123456789101112131415161718192021222324252627282930313233343536373839404142我们在```findClass()```方法中定义了查找class的方法，然后数据通过```defineClass()```生成了Class对象。 #### 测试现在我们要编写测试代码。我们知道如果调用一个Test对象的say方法，它会输出&quot;Say Hello&quot;这条字符串。但现在是我们把Test.class放置在应用工程所有的目录之外，我们需要加载它，然后执行它的方法。具体效果如何呢？我们编写的DiskClassLoader能不能顺利完成任务呢？我们拭目以待。 ``` javaimport java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class ClassLoaderTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub //创建自定义classloader对象。 DiskClassLoader diskLoader = new DiskClassLoader(&quot;D:\\\\lib&quot;); try &#123; //加载class文件 Class c = diskLoader.loadClass(&quot;com.frank.test.Test&quot;); if(c != null)&#123; try &#123; Object obj = c.newInstance(); Method method = c.getDeclaredMethod(&quot;say&quot;,null); //通过反射调用Test类的say方法 method.invoke(obj, null); &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 我们点击运行按钮，结果显示。 可以看到，Test类的say方法正确执行，也就是我们写的DiskClassLoader编写成功。 回首讲了这么大的篇幅，自定义ClassLoader才姗姗来迟。 很多同学可能觉得前面有些啰嗦，但我按照自己的思路，我觉得还是有必要的。因为我是围绕一个关键字进行讲解的。 关键字是什么？ 关键字 路径 从开篇的环境变量 到3个主要的JDK自带的类加载器 到自定义的ClassLoader 它们的关联部分就是路径，也就是要加载的class或者是资源的路径。BootStrap ClassLoader、ExtClassLoader、AppClassLoader都是加载指定路径下的jar包。如果我们要突破这种限制，实现自己某些特殊的需求，我们就得自定义ClassLoader，自已指定加载的路径，可以是磁盘、内存、网络或者其它。 所以，你说路径能不能成为它们的关键字？ 当然上面的只是我个人的看法，可能不正确，但现阶段，这样有利于自己的学习理解。 自定义ClassLoader还能做什么？突破了JDK系统内置加载路径的限制之后，我们就可以编写自定义ClassLoader，然后剩下的就叫给开发者你自己了。你可以按照自己的意愿进行业务的定制，将ClassLoader玩出花样来。 玩出花之Class解密类加载器常见的用法是将Class文件按照某种加密手段进行加密，然后按照规则编写自定义的ClassLoader进行解密，这样我们就可以在程序中加载特定了类，并且这个类只能被我们自定义的加载器进行加载，提高了程序的安全性。 下面，我们编写代码。 1.定义加密解密协议加密和解密的协议有很多种，具体怎么定看业务需要。在这里，为了便于演示，我简单地将加密解密定义为异或运算。当一个文件进行异或运算后，产生了加密文件，再进行一次异或后，就进行了解密。 2.编写加密工具类12345678910111213141516171819202122232425262728293031323334import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class FileUtils &#123; public static void test(String path)&#123; File file = new File(path); try &#123; FileInputStream fis = new FileInputStream(file); FileOutputStream fos = new FileOutputStream(path+\"en\"); int b = 0; int b1 = 0; try &#123; while((b = fis.read()) != -1)&#123; //每一个byte异或一个数字2 fos.write(b ^ 2); &#125; fos.close(); fis.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 我们再写测试代码1FileUtils.test(\"D:\\\\lib\\\\Test.class\"); 然后可以看见路径1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768### 编写自定义classloader，DeClassLoader``` javaimport java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;public class DeClassLoader extends ClassLoader &#123; private String mLibPath; public DeClassLoader(String path) &#123; // TODO Auto-generated constructor stub mLibPath = path; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; // TODO Auto-generated method stub String fileName = getFileName(name); File file = new File(mLibPath,fileName); try &#123; FileInputStream is = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int len = 0; byte b = 0; try &#123; while ((len = is.read()) != -1) &#123; //将数据异或一个数字2进行解密 b = (byte) (len ^ 2); bos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; byte[] data = bos.toByteArray(); is.close(); bos.close(); return defineClass(name,data,0,data.length); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return super.findClass(name); &#125; //获取要加载 的class文件名 private String getFileName(String name) &#123; // TODO Auto-generated method stub int index = name.lastIndexOf(&apos;.&apos;); if(index == -1)&#123; return name+&quot;.classen&quot;; &#125;else&#123; return name.substring(index+1)+&quot;.classen&quot;; &#125; &#125; &#125; 测试我们可以在ClassLoaderTest.java中的main方法中如下编码：12345678910111213141516171819202122232425DeClassLoader diskLoader = new DeClassLoader(\"D:\\\\lib\"); try &#123; //加载class文件 Class c = diskLoader.loadClass(\"com.frank.test.Test\"); if(c != null)&#123; try &#123; Object obj = c.newInstance(); Method method = c.getDeclaredMethod(\"say\",null); //通过反射调用Test类的say方法 method.invoke(obj, null); &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; 查看运行结果是： 可以看到了，同样成功了。现在，我们有两个自定义的ClassLoader:DiskClassLoader和DeClassLoader，我们可以尝试一下，看看DiskClassLoader能不能加载Test.classen文件也就是Test.class加密后的文件。 我们首先移除12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152``` javaDeClassLoader diskLoader1 = new DeClassLoader(&quot;D:\\\\lib&quot;); try &#123; //加载class文件 Class c = diskLoader1.loadClass(&quot;com.frank.test.Test&quot;); if(c != null)&#123; try &#123; Object obj = c.newInstance(); Method method = c.getDeclaredMethod(&quot;say&quot;,null); //通过反射调用Test类的say方法 method.invoke(obj, null); &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; DiskClassLoader diskLoader = new DiskClassLoader(&quot;D:\\\\lib&quot;); try &#123; //加载class文件 Class c = diskLoader.loadClass(&quot;com.frank.test.Test&quot;); if(c != null)&#123; try &#123; Object obj = c.newInstance(); Method method = c.getDeclaredMethod(&quot;say&quot;,null); //通过反射调用Test类的say方法 method.invoke(obj, null); &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 运行结果： 我们可以看到。DeClassLoader运行正常，而DiskClassLoader却找不到Test.class的类,并且它也无法加载Test.classen文件。 Context ClassLoader 线程上下文类加载器前面讲到过Bootstrap ClassLoader、ExtClassLoader、AppClassLoader，现在又出来这么一个类加载器，这是为什么？ 前面三个之所以放在前面讲，是因为它们是真实存在的类，而且遵从”双亲委托“的机制。而ContextClassLoader其实只是一个概念。 查看Thread.java源码可以发现123456789101112131415161718192021222324public class Thread implements Runnable &#123;/* The context ClassLoader for this thread */ private ClassLoader contextClassLoader; public void setContextClassLoader(ClassLoader cl) &#123; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; sm.checkPermission(new RuntimePermission(\"setContextClassLoader\")); &#125; contextClassLoader = cl; &#125; public ClassLoader getContextClassLoader() &#123; if (contextClassLoader == null) return null; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; ClassLoader.checkClassLoaderPermission(contextClassLoader, Reflection.getCallerClass()); &#125; return contextClassLoader; &#125;&#125; contextClassLoader只是一个成员变量，通过1234567891011121314151617 每个Thread都有一个相关联的ClassLoader，默认是AppClassLoader。并且子线程默认使用父线程的ClassLoader除非子线程特别设置。 我们同样可以编写代码来加深理解。 现在有2个SpeakTest.class文件，一个源码是 ``` javapackage com.frank.test;public class SpeakTest implements ISpeak &#123; @Override public void speak() &#123; // TODO Auto-generated method stub System.out.println(&quot;Test&quot;); &#125;&#125; 它生成的SpeakTest.class文件放置在12345678 另外ISpeak.java代码 ``` java package com.frank.test;public interface ISpeak &#123; public void speak();&#125; 然后，我们在这里还实现了一个SpeakTest.java1234567891011package com.frank.test;public class SpeakTest implements ISpeak &#123; @Override public void speak() &#123; // TODO Auto-generated method stub System.out.println(\"I\\' frank\"); &#125;&#125; 它生成的SpeakTest.class文件放置在12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273然后我们还要编写另外一个ClassLoader，DiskClassLoader1.java这个ClassLoader的代码和DiskClassLoader.java代码一致，我们要在DiskClassLoader1中加载位置于```D:\\\\lib\\\\test```中的SpeakTest.class文件。测试代码：``` javaDiskClassLoader1 diskLoader1 = new DiskClassLoader1(&quot;D:\\\\lib\\\\test&quot;);Class cls1 = null;try &#123;//加载class文件 cls1 = diskLoader1.loadClass(&quot;com.frank.test.SpeakTest&quot;);System.out.println(cls1.getClassLoader().toString());if(cls1 != null)&#123; try &#123; Object obj = cls1.newInstance(); //SpeakTest1 speak = (SpeakTest1) obj; //speak.speak(); Method method = cls1.getDeclaredMethod(&quot;speak&quot;,null); //通过反射调用Test类的speak方法 method.invoke(obj, null); &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;&#125; catch (ClassNotFoundException e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125; DiskClassLoader diskLoader = new DiskClassLoader(&quot;D:\\\\lib&quot;);System.out.println(&quot;Thread &quot;+Thread.currentThread().getName()+&quot; classloader: &quot;+Thread.currentThread().getContextClassLoader().toString());new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;Thread &quot;+Thread.currentThread().getName()+&quot; classloader: &quot;+Thread.currentThread().getContextClassLoader().toString()); // TODO Auto-generated method stub try &#123; //加载class文件 // Thread.currentThread().setContextClassLoader(diskLoader); //Class c = diskLoader.loadClass(&quot;com.frank.test.SpeakTest&quot;); ClassLoader cl = Thread.currentThread().getContextClassLoader(); Class c = cl.loadClass(&quot;com.frank.test.SpeakTest&quot;); // Class c = Class.forName(&quot;com.frank.test.SpeakTest&quot;); System.out.println(c.getClassLoader().toString()); if(c != null)&#123; try &#123; Object obj = c.newInstance(); //SpeakTest1 speak = (SpeakTest1) obj; //speak.speak(); Method method = c.getDeclaredMethod(&quot;speak&quot;,null); //通过反射调用Test类的say方法 method.invoke(obj, null); &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;).start(); 结果如下： 我们可以得到如下的信息： DiskClassLoader1加载成功了SpeakTest.class文件并执行成功。 子线程的ContextClassLoader是AppClassLoader。 AppClassLoader加载不了父线程当中已经加载的SpeakTest.class内容。 我们修改一下代码，在子线程开头处加上这么一句内容。1Thread.currentThread().setContextClassLoader(diskLoader1); 结果如下： 可以看到子线程的ContextClassLoader变成了DiskClassLoader。 继续改动代码：1Thread.currentThread().setContextClassLoader(diskLoader); 结果： 可以看到DiskClassLoader1和DiskClassLoader分别加载了自己路径下的SpeakTest.class文件，并且它们的类名是一样的com.frank.test.SpeakTest，但是执行结果不一样，因为它们的实际内容不一样。 Context ClassLoader的运用时机其实这个我也不是很清楚，我的主业是Android，研究ClassLoader也是为了更好的研究Android。网上的答案说是适应那些Web服务框架软件如Tomcat等。主要为了加载不同的APP，因为加载器不一样，同一份class文件加载后生成的类是不相等的。如果有同学想多了解更多的细节，请自行查阅相关资料。 总结 ClassLoader用来加载class文件的。 系统内置的ClassLoader通过双亲委托来加载指定路径下的class和资源。 可以自定义ClassLoader一般覆盖findClass()方法。 ContextClassLoader与线程相关，可以获取和设置，可以绕过双亲委托的机制。 下一步 你可以研究ClassLoader在Web容器内的应用了，如Tomcat。 可以尝试以这个为基础，继续学习Android中的ClassLoader机制。 引用我这篇文章写了好几天，修修改改，然后加上自己的理解。参考了下面的这些网站。 grepcode ClassLoader源码 http://blog.csdn.net/xyang81/article/details/7292380 http://blog.csdn.net/irelandken/article/details/7048817 https://docs.oracle.com/javase/7/docs/api/java/net/URLClassLoader.html","tags":[]},{"title":"一看你懂，超详细的Java中的ClassLoader讲解","date":"2017-02-11T08:10:40.000Z","path":"2017/02/11/一看你就懂，超详细的Java中的ClassLoader讲解/","text":"ClassLoader翻译过来就是类加载器，普通的java开发者其实用到的不多，但对于某些框架开发者来说却非常常见。理解ClassLoader的加载机制，也有利于我们编写出更高效的代码。ClassLoader的具体作用就是将class文件加载到jvm虚拟机中去，程序就可以正确运行了。但是，jvm启动的时候，并不会一次性加载所有的class文件，而是根据需要去动态加载。想想也是的，一次性加载那么多jar包那么多class，那内存不崩溃。本文的目的也是学习ClassLoader这种加载机制。 备注：本文篇幅比较长，但内容简单，大家不要恐慌，安静地耐心翻阅就是 Class文件的认识我们都知道在Java中程序是运行在虚拟机中，我们平常用文本编辑器或者是IDE编写的程序都是.java格式的文件，这是最基础的源码，但这类文件是不能直接运行的。如我们编写一个简单的程序HelloWorld.java12345678910111213141516171819202122232425262728293031323334353637383940414243public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println(\"Hello world!\"); &#125;&#125;``` 如图： ![这里写图片描述](http://img.blog.csdn.net/20170210191722848?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)然后，我们需要在命令行中进行java文件的编译```cmdjavac HelloWorld.java``` ![这里写图片描述](http://img.blog.csdn.net/20170210191806786?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)可以看到目录下生成了.class文件 我们再从命令行中执行命令： ```cmdjava HelloWorld``` ![这里写图片描述](http://img.blog.csdn.net/20170210191838803?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)上面是基本代码示例，是所有入门JAVA语言时都学过的东西，这里重新拿出来是想让大家将焦点回到class文件上，class文件是字节码格式文件，java虚拟机并不能直接识别我们平常编写的.java源文件，所以需要javac这个命令转换成.class文件。另外，如果用C或者PYTHON编写的程序正确转换成.class文件后，java虚拟机也是可以识别运行的。更多信息大家可以参考[这篇](http://blog.csdn.net/zhangjg_blog/article/details/21486985)。 了解了.class文件后，我们再来思考下，我们平常在Eclipse中编写的java程序是如何运行的，也就是我们自己编写的各种类是如何被加载到jvm(java虚拟机)中去的。 # 你还记得java环境变量吗？ 初学java的时候，最害怕的就是下载JDK后要配置环境变量了，关键是当时不理解，所以战战兢兢地照着书籍上或者是网络上的介绍进行操作。然后下次再弄的时候，又忘记了而且是必忘。当时，心里的想法很气愤的，想着是--这东西一点也不人性化，为什么非要自己配置环境变量呢？太不照顾菜鸟和新手了，很多菜鸟就是因为卡在环境变量的配置上，遭受了太多的挫败感。 因为我是在Windows下编程的，所以只讲Window平台上的环境变量，主要有3个：**JAVA_HOME**、**PATH**、**CLASSPATH**。 ## JAVA_HOME 指的是你JDK安装的位置，一般默认安装在C盘，如```cmdC:\\Program Files\\Java\\jdk1.8.0_91``` ## PATH 将程序路径包含在PATH当中后，在命令行窗口就可以直接键入它的名字了，而不再需要键入它的全路径,比如上面代码中我用的到```javac```和```java```两个命令。 一般的 ```cmdPATH=%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;%PATH%; 也就是在原来的PATH路径上添加JDK目录下的bin目录和jre目录的bin. CLASSPATH123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CLASSPATH=.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar``` 一看就是指向jar包路径。 需要注意的是前面的```.;```，```.```代表当前目录。 ## 环境变量的设置与查看设置可以右击我的电脑，然后点击属性，再点击高级，然后点击环境变量，具体不明白的自行查阅文档。 查看的话可以打开命令行窗口```cmdecho %JAVA_HOME%echo %PATH%echo %CLASSPATH%``` 好了，扯远了，知道了环境变量，特别是CLASSPATH时，我们进入今天的主题Classloader. # JAVA类加载流程 Java语言系统自带有三个类加载器:- **Bootstrap ClassLoader** 最顶层的加载类，主要加载核心类库，%JRE_HOME%\\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如```java -Xbootclasspath/a:path ```被指定的文件追加到默认的bootstrap路径中。我们可以打开我的电脑，在上面的目录下查看，看看这些jar包是不是存在于这个目录。 - **Extention ClassLoader** 扩展的类加载器，加载目录%JRE_HOME%\\lib\\ext目录下的jar包和class文件。还可以加载```-D java.ext.dirs```选项指定的目录。- **Appclass Loader也称为SystemAppClass** 加载当前应用的classpath的所有类。 我们上面简单介绍了3个ClassLoader。说明了它们加载的路径。并且还提到了```-Xbootclasspath```和```-D java.ext.dirs```这两个虚拟机参数选项。 ## 加载顺序？我们看到了系统的3个类加载器，但我们可能不知道具体哪个先行呢？ 我可以先告诉你答案1. Bootstrap CLassloder 2. Extention ClassLoader 3. AppClassLoader 为了更好的理解，我们可以查看源码。 看[sun.misc.Launcher](http://www.grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/misc/Launcher.java),它是一个java虚拟机的入口应用。 ```javapublic class Launcher &#123; private static Launcher launcher = new Launcher(); private static String bootClassPath = System.getProperty(\"sun.boot.class.path\"); public static Launcher getLauncher() &#123; return launcher; &#125; private ClassLoader loader; public Launcher() &#123; // Create the extension class loader ClassLoader extcl; try &#123; extcl = ExtClassLoader.getExtClassLoader(); &#125; catch (IOException e) &#123; throw new InternalError( \"Could not create extension class loader\", e); &#125; // Now create the class loader to use to launch the application try &#123; loader = AppClassLoader.getAppClassLoader(extcl); &#125; catch (IOException e) &#123; throw new InternalError( \"Could not create application class loader\", e); &#125; //设置AppClassLoader为线程上下文类加载器，这个文章后面部分讲解 Thread.currentThread().setContextClassLoader(loader); &#125; /* * Returns the class loader used to launch the main application. */ public ClassLoader getClassLoader() &#123; return loader; &#125; /* * The class loader used for loading installed extensions. */ static class ExtClassLoader extends URLClassLoader &#123;&#125;/** * The class loader used for loading from java.class.path. * runs in a restricted security context. */ static class AppClassLoader extends URLClassLoader &#123;&#125;``` 源码有精简，我们可以得到相关的信息。 1. Launcher初始化了ExtClassLoader和AppClassLoader。2. Launcher中并没有看见BootstrapClassLoader，但通过```System.getProperty(\"sun.boot.class.path\")```得到了字符串```bootClassPath```,这个应该就是BootstrapClassLoader加载的jar包路径。 我们可以先代码测试一下```sun.boot.class.path```是什么内容。 ```javaSystem.out.println(System.getProperty(\"sun.boot.class.path\")); 得到的结果是：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576C:\\Program Files\\Java\\jre1.8.0_91\\lib\\resources.jar;C:\\Program Files\\Java\\jre1.8.0_91\\lib\\rt.jar;C:\\Program Files\\Java\\jre1.8.0_91\\lib\\sunrsasign.jar;C:\\Program Files\\Java\\jre1.8.0_91\\lib\\jsse.jar;C:\\Program Files\\Java\\jre1.8.0_91\\lib\\jce.jar;C:\\Program Files\\Java\\jre1.8.0_91\\lib\\charsets.jar;C:\\Program Files\\Java\\jre1.8.0_91\\lib\\jfr.jar;C:\\Program Files\\Java\\jre1.8.0_91\\classes``` 可以看到，这些全是JRE目录下的jar包或者是class文件。 ### ExtClassLoader源码如果你有足够的好奇心，你应该会对它的源码感兴趣```java/* * The class loader used for loading installed extensions. */ static class ExtClassLoader extends URLClassLoader &#123; static &#123; ClassLoader.registerAsParallelCapable(); &#125; /** * create an ExtClassLoader. The ExtClassLoader is created * within a context that limits which files it can read */ public static ExtClassLoader getExtClassLoader() throws IOException &#123; final File[] dirs = getExtDirs(); try &#123; // Prior implementations of this doPrivileged() block supplied // aa synthesized ACC via a call to the private method // ExtClassLoader.getContext(). return AccessController.doPrivileged( new PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123; public ExtClassLoader run() throws IOException &#123; int len = dirs.length; for (int i = 0; i &lt; len; i++) &#123; MetaIndex.registerDirectory(dirs[i]); &#125; return new ExtClassLoader(dirs); &#125; &#125;); &#125; catch (java.security.PrivilegedActionException e) &#123; throw (IOException) e.getException(); &#125; &#125; private static File[] getExtDirs() &#123; String s = System.getProperty(&quot;java.ext.dirs&quot;); File[] dirs; if (s != null) &#123; StringTokenizer st = new StringTokenizer(s, File.pathSeparator); int count = st.countTokens(); dirs = new File[count]; for (int i = 0; i &lt; count; i++) &#123; dirs[i] = new File(st.nextToken()); &#125; &#125; else &#123; dirs = new File[0]; &#125; return dirs; &#125; ...... &#125;``` 我们先前的内容有说过，可以指定```-D java.ext.dirs```参数来添加和改变ExtClassLoader的加载路径。这里我们通过可以编写测试代码。 ```java System.out.println(System.getProperty(&quot;java.ext.dirs&quot;));``` 结果如下： C:\\Program Files\\Java\\jre1.8.0_91\\lib\\ext;C:\\Windows\\Sun\\Java\\lib\\ext1234567891011121314151617181920212223242526272829### AppClassLoader源码 ```java /** * The class loader used for loading from java.class.path. * runs in a restricted security context. */ static class AppClassLoader extends URLClassLoader &#123; public static ClassLoader getAppClassLoader(final ClassLoader extcl) throws IOException &#123; final String s = System.getProperty(&quot;java.class.path&quot;); final File[] path = (s == null) ? new File[0] : getClassPath(s); return AccessController.doPrivileged( new PrivilegedAction&lt;AppClassLoader&gt;() &#123; public AppClassLoader run() &#123; URL[] urls = (s == null) ? new URL[0] : pathToURLs(path); return new AppClassLoader(urls, extcl); &#125; &#125;); &#125; ...... &#125; 可以看到AppClassLoader加载的就是12```javaSystem.out.println(System.getProperty(&quot;java.class.path&quot;)); 结果：1D:\\workspace\\ClassLoaderDemo\\bin 这个路径其实就是当前java工程目录bin，里面存放的是编译生成的class文件。 好了，自此我们已经知道了BootstrapClassLoader、ExtClassLoader、AppClassLoader实际是查阅相应的环境属性123456789101112131415161718192021222324接下来我们探讨它们的加载顺序，我们先用Eclipse建立一个java工程。![这里写图片描述](http://img.blog.csdn.net/20170210192102102?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)然后创建一个```Test.java```文件。```javapublic class Test&#123;&#125;``` 然后，编写一个ClassLoaderTest.java文件。```javapublic class ClassLoaderTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ClassLoader cl = Test.class.getClassLoader(); System.out.println(&quot;ClassLoader is:&quot;+cl.toString()); &#125;&#125;``` 我们获取到了Test.class文件的类加载器，然后打印出来。结果是： ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93123456789101112131415161718192021也就是说明Test.class文件是由AppClassLoader加载的。这个Test类是我们自己编写的，那么int.class或者是String.class的加载是由谁完成的呢？我们可以在代码中尝试 ```javapublic class ClassLoaderTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ClassLoader cl = Test.class.getClassLoader(); System.out.println(&quot;ClassLoader is:&quot;+cl.toString()); cl = int.class.getClassLoader(); System.out.println(&quot;ClassLoader is:&quot;+cl.toString()); &#125;&#125; 运行一下，却报错了123ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93Exception in thread &quot;main&quot; java.lang.NullPointerException at ClassLoaderTest.main(ClassLoaderTest.java:15) 提示的是空指针，意思是int.class这类基础类没有类加载器加载？ 当然不是！int.class是由Bootstrap ClassLoader加载的。要想弄明白这些，我们首先得知道一个前提。 每个类加载器都有一个父加载器每个类加载器都有一个父加载器，比如加载Test.class是由AppClassLoader完成，那么AppClassLoader也有一个父加载器，怎么样获取呢？很简单，通过getParent方法。比如代码可以这样编写：123456ClassLoader cl = Test.class.getClassLoader(); System.out.println(\"ClassLoader is:\"+cl.toString());System.out.println(\"ClassLoader\\'s parent is:\"+cl.getParent().toString());``` 运行结果如下： ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93ClassLoader’s parent is:sun.misc.Launcher$ExtClassLoader@15db97421234567这个说明，AppClassLoader的父加载器是ExtClassLoader。那么ExtClassLoader的父加载器又是谁呢？```javaSystem.out.println(&quot;ClassLoader is:&quot;+cl.toString());System.out.println(&quot;ClassLoader\\&apos;s parent is:&quot;+cl.getParent().toString());System.out.println(&quot;ClassLoader\\&apos;s grand father is:&quot;+cl.getParent().getParent().toString());``` 运行如果： ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93Exception in thread “main” ClassLoader’s parent is:sun.misc.Launcher$ExtClassLoader@15db9742java.lang.NullPointerException at ClassLoaderTest.main(ClassLoaderTest.java:13)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164又是一个空指针异常，这表明ExtClassLoader也没有父加载器。那么，为什么标题又是每一个加载器都有一个父加载器呢？这不矛盾吗？为了解释这一点，我们还需要看下面的一个基础前提。 ## 父加载器不是父类 我们先前已经粘贴了ExtClassLoader和AppClassLoader的代码。```javastatic class ExtClassLoader extends URLClassLoader &#123;&#125;static class AppClassLoader extends URLClassLoader &#123;&#125;``` 可以看见ExtClassLoader和AppClassLoader同样继承自URLClassLoader，但上面一小节代码中，为什么调用AppClassLoader的```getParent()```代码会得到ExtClassLoader的实例呢？先从URLClassLoader说起，这个类又是什么？ 先上一张类的继承关系图 ![这里写图片描述](http://img.blog.csdn.net/20170211112754197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) URLClassLoader的源码中并没有找到```getParent()```方法。这个方法在ClassLoader.java中。 ```javapublic abstract class ClassLoader &#123;// The parent class loader for delegation// Note: VM hardcoded the offset of this field, thus all new fields// must be added *after* it.private final ClassLoader parent;// The class loader for the system // @GuardedBy(&quot;ClassLoader.class&quot;)private static ClassLoader scl;private ClassLoader(Void unused, ClassLoader parent) &#123; this.parent = parent; ...&#125;protected ClassLoader(ClassLoader parent) &#123; this(checkCreateClassLoader(), parent);&#125;protected ClassLoader() &#123; this(checkCreateClassLoader(), getSystemClassLoader());&#125;public final ClassLoader getParent() &#123; if (parent == null) return null; return parent;&#125;public static ClassLoader getSystemClassLoader() &#123; initSystemClassLoader(); if (scl == null) &#123; return null; &#125; return scl;&#125;private static synchronized void initSystemClassLoader() &#123; if (!sclSet) &#123; if (scl != null) throw new IllegalStateException(&quot;recursive invocation&quot;); sun.misc.Launcher l = sun.misc.Launcher.getLauncher(); if (l != null) &#123; Throwable oops = null; //通过Launcher获取ClassLoader scl = l.getClassLoader(); try &#123; scl = AccessController.doPrivileged( new SystemClassLoaderAction(scl)); &#125; catch (PrivilegedActionException pae) &#123; oops = pae.getCause(); if (oops instanceof InvocationTargetException) &#123; oops = oops.getCause(); &#125; &#125; if (oops != null) &#123; if (oops instanceof Error) &#123; throw (Error) oops; &#125; else &#123; // wrap the exception throw new Error(oops); &#125; &#125; &#125; sclSet = true; &#125;&#125;&#125;``` 我们可以看到```getParent()```实际上返回的就是一个ClassLoader对象parent，parent的赋值是在ClassLoader对象的构造方法中，它有两个情况： 1. 由外部类创建ClassLoader时直接指定一个ClassLoader为parent。 2. 由```getSystemClassLoader()```方法生成，也就是在sun.misc.Laucher通过```getClassLoader()```获取，也就是AppClassLoader。直白的说，一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。 我们主要研究的是ExtClassLoader与AppClassLoader的parent的来源，正好它们与Launcher类有关，我们上面已经粘贴过Launcher的部分代码。 ```java public class Launcher &#123; private static URLStreamHandlerFactory factory = new Factory(); private static Launcher launcher = new Launcher(); private static String bootClassPath = System.getProperty(&quot;sun.boot.class.path&quot;); public static Launcher getLauncher() &#123; return launcher; &#125; private ClassLoader loader; public Launcher() &#123; // Create the extension class loader ClassLoader extcl; try &#123; extcl = ExtClassLoader.getExtClassLoader(); &#125; catch (IOException e) &#123; throw new InternalError( &quot;Could not create extension class loader&quot;, e); &#125; // Now create the class loader to use to launch the application try &#123; //将ExtClassLoader对象实例传递进去 loader = AppClassLoader.getAppClassLoader(extcl); &#125; catch (IOException e) &#123; throw new InternalError( &quot;Could not create application class loader&quot;, e); &#125;public ClassLoader getClassLoader() &#123; return loader; &#125;static class ExtClassLoader extends URLClassLoader &#123; /** * create an ExtClassLoader. The ExtClassLoader is created * within a context that limits which files it can read */ public static ExtClassLoader getExtClassLoader() throws IOException &#123; final File[] dirs = getExtDirs(); try &#123; // Prior implementations of this doPrivileged() block supplied // aa synthesized ACC via a call to the private method // ExtClassLoader.getContext(). return AccessController.doPrivileged( new PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123; public ExtClassLoader run() throws IOException &#123; //ExtClassLoader在这里创建 return new ExtClassLoader(dirs); &#125; &#125;); &#125; catch (java.security.PrivilegedActionException e) &#123; throw (IOException) e.getException(); &#125; &#125; /* * Creates a new ExtClassLoader for the specified directories. */ public ExtClassLoader(File[] dirs) throws IOException &#123; super(getExtURLs(dirs), null, factory); &#125; &#125; &#125;``` 我们需要注意的是```javaClassLoader extcl; extcl = ExtClassLoader.getExtClassLoader();loader = AppClassLoader.getAppClassLoader(extcl); 代码已经说明了问题AppClassLoader的parent是一个ExtClassLoader实例。 ExtClassLoader并没有直接找到对parent的赋值。它调用了它的父类也就是URLClassLoder的构造方法并传递了3个参数。123public ExtClassLoader(File[] dirs) throws IOException &#123; super(getExtURLs(dirs), null, factory); &#125; 对应的代码1234public URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory) &#123; super(parent);&#125; 答案已经很明了了，ExtClassLoader的parent为null。 上面张贴这么多代码也是为了说明AppClassLoader的parent是ExtClassLoader，ExtClassLoader的parent是null。这符合我们之前编写的测试代码。 不过，细心的同学发现，还是有疑问的我们只看到ExtClassLoader和AppClassLoader的创建，那么BootstrapClassLoader呢？ 还有，ExtClassLoader的父加载器为null,但是Bootstrap CLassLoader却可以当成它的父加载器这又是为何呢？ 我们继续往下进行。 Bootstrap ClassLoader是由C++编写的。Bootstrap ClassLoader是由C/C++编写的，它本身是虚拟机的一部分，所以它并不是一个JAVA类，也就是无法在java代码中获取它的引用，JVM启动时通过Bootstrap类加载器加载rt.jar等核心jar包中的class文件，之前的int.class,String.class都是由它加载。然后呢，我们前面已经分析了，JVM初始化sun.misc.Launcher并创建Extension ClassLoader和AppClassLoader实例。并将ExtClassLoader设置为AppClassLoader的父加载器。Bootstrap没有父加载器，但是它却可以作用一个ClassLoader的父加载器。比如ExtClassLoader。这也可以解释之前通过ExtClassLoader的getParent方法获取为Null的现象。具体是什么原因，很快就知道答案了。 双亲委托双亲委托。我们终于来到了这一步了。一个类加载器查找class和resource时，是通过“委托模式”进行的，它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap classloader找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。整个流程可以如下图所示：这张图是用时序图画出来的，不过画出来的结果我却自己都觉得不理想。 大家可以看到2根箭头，蓝色的代表类加载器向上委托的方向，如果当前的类加载器没有查询到这个class对象已经加载就请求父加载器（不一定是父类）进行操作，然后以此类推。直到Bootstrap ClassLoader。如果Bootstrap ClassLoader也没有加载过此class实例，那么它就会从它指定的路径中去查找，如果查找成功则返回，如果没有查找成功则交给子类加载器，也就是ExtClassLoader,这样类似操作直到终点，也就是我上图中的红色箭头示例。用序列描述一下： 一个AppClassLoader查找资源时，先看看缓存是否有，缓存有从缓存中获取，否则委托给父加载器。 递归，重复第1部的操作。 如果ExtClassLoader也没有加载过，则由Bootstrap ClassLoader出面，它首先查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241254. Bootstrap ClassLoader如果没有查找成功，则ExtClassLoader自己在```java.ext.dirs```路径中去查找，查找成功就返回，查找不成功，再向下让子加载器找。 5. ExtClassLoader查找不成功，AppClassLoader就自己查找，在```java.class.path```路径下查找。找到就返回。如果没有找到就让子类找，如果没有子类会怎么样？抛出各种异常。 上面的序列，详细说明了双亲委托的加载流程。**我们可以发现委托是从下向上，然后具体查找过程却是自上至下。**我说过上面用时序图画的让自己不满意，现在用框图，最原始的方法再画一次。 ![这里写图片描述](http://img.blog.csdn.net/20170211135054825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)上面已经详细介绍了加载过程，但具体为什么是这样加载，我们还需要了解几个个重要的方法loadClass()、findLoadedClass()、findClass()、defineClass()。## 重要方法### loadClass()JDK文档中是这样写的，通过指定的全限定类名加载class，它通过同名的loadClass(String,boolean)方法。```javaprotected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException``` 上面是方法原型，一般实现这个方法的步骤是1. 执行```findLoadedClass(String)```去检测这个class是不是已经加载过了。2. 执行父加载器的```loadClass```方法。如果父加载器为null，则jvm内置的加载器去替代，也就是Bootstrap ClassLoader。这也解释了ExtClassLoader的parent为null,但仍然说Bootstrap ClassLoader是它的父加载器。 3. 如果向上委托父加载器没有加载成功，则通过```findClass(String)```查找。 如果class在上面的步骤中找到了，参数resolve又是true的话，那么```loadClass()```又会调用```resolveClass(Class)```这个方法来生成最终的Class对象。 我们可以从源代码看出这个步骤。 ```javaprotected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // 首先，检测是否已经加载 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //父加载器不为空则调用父加载器的loadClass c = parent.loadClass(name, false); &#125; else &#123; //父加载器为空则调用Bootstrap Classloader c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); //父加载器没有找到，则调用findclass c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; //调用resolveClass() resolveClass(c); &#125; return c; &#125; &#125;``` 代码解释了双亲委托。另外，要注意的是如果要编写一个classLoader的子类，也就是自定义一个classloader，建议覆盖```findClass()```方法，而不要直接改写```loadClass()```方法。 另外```javaif (parent != null) &#123; //父加载器不为空则调用父加载器的loadClass c = parent.loadClass(name, false);&#125; else &#123; //父加载器为空则调用Bootstrap Classloader c = findBootstrapClassOrNull(name);&#125;``` 前面说过ExtClassLoader的parent为null，所以它向上委托时，系统会为它指定Bootstrap ClassLoader。# 自定义ClassLoader 不知道大家有没有发现，不管是Bootstrap ClassLoader还是ExtClassLoader等，这些类加载器都只是加载指定的目录下的jar包或者资源。如果在某种情况下，我们需要动态加载一些东西呢？比如从D盘某个文件夹加载一个class文件，或者从网络上下载class主内容然后再进行加载，这样可以吗？ 如果要这样做的话，需要我们自定义一个classloader。 ## 自定义步骤1. 编写一个类继承自ClassLoader抽象类。 2. 复写它的```findClass()```方法。3. 在```findClass()```方法中调用```defineClass()```。 ### defineClass()这个方法在编写自定义classloader的时候非常重要，它能将class二进制内容转换成Class对象，如果不符合要求的会抛出各种异常。 ## 注意点：**一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。 **上面说的是，如果自定义一个ClassLoader，默认的parent父加载器是AppClassLoader，因为这样就能够保证它能访问系统内置加载器加载成功的class文件。## 自定义ClassLoader示例之DiskClassLoader。假设我们需要一个自定义的classloader,默认加载路径为```D:\\lib```下的jar包和资源。 我们写编写一个测试用的类文件，Test.java#### Test.java```javapackage com.frank.test;public class Test &#123; public void say()&#123; System.out.println(&quot;Say Hello&quot;); &#125;&#125;``` 然后将它编译过年class文件Test.class放到```D:\\lib```这个路径下。#### DiskClassLoader 我们编写DiskClassLoader的代码。 import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException; public class DiskClassLoader extends ClassLoader { private String mLibPath; public DiskClassLoader(String path) { // TODO Auto-generated constructor stub mLibPath = path; } @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { // TODO Auto-generated method stub String fileName = getFileName(name); File file = new File(mLibPath,fileName); try { FileInputStream is = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int len = 0; try { while ((len = is.read()) != -1) { bos.write(len); } } catch (IOException e) { e.printStackTrace(); } byte[] data = bos.toByteArray(); is.close(); bos.close(); return defineClass(name,data,0,data.length); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } return super.findClass(name); } //获取要加载 的class文件名 private String getFileName(String name) { // TODO Auto-generated method stub int index = name.lastIndexOf(&apos;.&apos;); if(index == -1){ return name+&quot;.class&quot;; }else{ return name.substring(index)+&quot;.class&quot;; } } }123456789101112131415161718192021222324252627282930313233343536373839404142我们在```findClass()```方法中定义了查找class的方法，然后数据通过```defineClass()```生成了Class对象。 #### 测试现在我们要编写测试代码。我们知道如果调用一个Test对象的say方法，它会输出&quot;Say Hello&quot;这条字符串。但现在是我们把Test.class放置在应用工程所有的目录之外，我们需要加载它，然后执行它的方法。具体效果如何呢？我们编写的DiskClassLoader能不能顺利完成任务呢？我们拭目以待。 ```javaimport java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class ClassLoaderTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub //创建自定义classloader对象。 DiskClassLoader diskLoader = new DiskClassLoader(&quot;D:\\\\lib&quot;); try &#123; //加载class文件 Class c = diskLoader.loadClass(&quot;com.frank.test.Test&quot;); if(c != null)&#123; try &#123; Object obj = c.newInstance(); Method method = c.getDeclaredMethod(&quot;say&quot;,null); //通过反射调用Test类的say方法 method.invoke(obj, null); &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 我们点击运行按钮，结果显示。 可以看到，Test类的say方法正确执行，也就是我们写的DiskClassLoader编写成功。 回首讲了这么大的篇幅，自定义ClassLoader才姗姗来迟。 很多同学可能觉得前面有些啰嗦，但我按照自己的思路，我觉得还是有必要的。因为我是围绕一个关键字进行讲解的。 关键字是什么？ 关键字 路径 从开篇的环境变量 到3个主要的JDK自带的类加载器 到自定义的ClassLoader 它们的关联部分就是路径，也就是要加载的class或者是资源的路径。BootStrap ClassLoader、ExtClassLoader、AppClassLoader都是加载指定路径下的jar包。如果我们要突破这种限制，实现自己某些特殊的需求，我们就得自定义ClassLoader，自已指定加载的路径，可以是磁盘、内存、网络或者其它。 所以，你说路径能不能成为它们的关键字？ 当然上面的只是我个人的看法，可能不正确，但现阶段，这样有利于自己的学习理解。 自定义ClassLoader还能做什么？突破了JDK系统内置加载路径的限制之后，我们就可以编写自定义ClassLoader，然后剩下的就叫给开发者你自己了。你可以按照自己的意愿进行业务的定制，将ClassLoader玩出花样来。 玩出花之Class解密类加载器常见的用法是将Class文件按照某种加密手段进行加密，然后按照规则编写自定义的ClassLoader进行解密，这样我们就可以在程序中加载特定了类，并且这个类只能被我们自定义的加载器进行加载，提高了程序的安全性。 下面，我们编写代码。 1.定义加密解密协议加密和解密的协议有很多种，具体怎么定看业务需要。在这里，为了便于演示，我简单地将加密解密定义为异或运算。当一个文件进行异或运算后，产生了加密文件，再进行一次异或后，就进行了解密。 2.编写加密工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class FileUtils &#123; public static void test(String path)&#123; File file = new File(path); try &#123; FileInputStream fis = new FileInputStream(file); FileOutputStream fos = new FileOutputStream(path+\"en\"); int b = 0; int b1 = 0; try &#123; while((b = fis.read()) != -1)&#123; //每一个byte异或一个数字2 fos.write(b ^ 2); &#125; fos.close(); fis.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;``` 我们再写测试代码```javaFileUtils.test(\"D:\\\\lib\\\\Test.class\");``` ![这里写图片描述](http://img.blog.csdn.net/20170210192432620?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)然后可以看见路径```D:\\\\lib\\\\Test.class```下Test.class生成了Test.classen文件。 ### 编写自定义classloader，DeClassLoader```javaimport java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;public class DeClassLoader extends ClassLoader &#123; private String mLibPath; public DeClassLoader(String path) &#123; // TODO Auto-generated constructor stub mLibPath = path; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; // TODO Auto-generated method stub String fileName = getFileName(name); File file = new File(mLibPath,fileName); try &#123; FileInputStream is = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int len = 0; byte b = 0; try &#123; while ((len = is.read()) != -1) &#123; //将数据异或一个数字2进行解密 b = (byte) (len ^ 2); bos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; byte[] data = bos.toByteArray(); is.close(); bos.close(); return defineClass(name,data,0,data.length); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return super.findClass(name); &#125; //获取要加载 的class文件名 private String getFileName(String name) &#123; // TODO Auto-generated method stub int index = name.lastIndexOf('.'); if(index == -1)&#123; return name+\".classen\"; &#125;else&#123; return name.substring(index+1)+\".classen\"; &#125; &#125; &#125;``` ### 测试我们可以在ClassLoaderTest.java中的main方法中如下编码：```javaDeClassLoader diskLoader = new DeClassLoader(\"D:\\\\lib\"); try &#123; //加载class文件 Class c = diskLoader.loadClass(\"com.frank.test.Test\"); if(c != null)&#123; try &#123; Object obj = c.newInstance(); Method method = c.getDeclaredMethod(\"say\",null); //通过反射调用Test类的say方法 method.invoke(obj, null); &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; 查看运行结果是： 可以看到了，同样成功了。现在，我们有两个自定义的ClassLoader:DiskClassLoader和DeClassLoader，我们可以尝试一下，看看DiskClassLoader能不能加载Test.classen文件也就是Test.class加密后的文件。 我们首先移除12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091```javaDeClassLoader diskLoader1 = new DeClassLoader(&quot;D:\\\\lib&quot;); try &#123; //加载class文件 Class c = diskLoader1.loadClass(&quot;com.frank.test.Test&quot;); if(c != null)&#123; try &#123; Object obj = c.newInstance(); Method method = c.getDeclaredMethod(&quot;say&quot;,null); //通过反射调用Test类的say方法 method.invoke(obj, null); &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; DiskClassLoader diskLoader = new DiskClassLoader(&quot;D:\\\\lib&quot;); try &#123; //加载class文件 Class c = diskLoader.loadClass(&quot;com.frank.test.Test&quot;); if(c != null)&#123; try &#123; Object obj = c.newInstance(); Method method = c.getDeclaredMethod(&quot;say&quot;,null); //通过反射调用Test类的say方法 method.invoke(obj, null); &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;``` 运行结果： ![这里写图片描述](http://img.blog.csdn.net/20170210192518030?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)我们可以看到。DeClassLoader运行正常，而DiskClassLoader却找不到Test.class的类,并且它也无法加载Test.classen文件。 # Context ClassLoader 线程上下文类加载器 前面讲到过Bootstrap ClassLoader、ExtClassLoader、AppClassLoader，现在又出来这么一个类加载器，这是为什么？ 前面三个之所以放在前面讲，是因为它们是真实存在的类，而且遵从”双亲委托“的机制。而ContextClassLoader其实只是一个概念。 查看Thread.java源码可以发现```javapublic class Thread implements Runnable &#123;/* The context ClassLoader for this thread */ private ClassLoader contextClassLoader; public void setContextClassLoader(ClassLoader cl) &#123; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; sm.checkPermission(new RuntimePermission(&quot;setContextClassLoader&quot;)); &#125; contextClassLoader = cl; &#125; public ClassLoader getContextClassLoader() &#123; if (contextClassLoader == null) return null; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; ClassLoader.checkClassLoaderPermission(contextClassLoader, Reflection.getCallerClass()); &#125; return contextClassLoader; &#125;&#125; contextClassLoader只是一个成员变量，通过1234567891011121314151617 每个Thread都有一个相关联的ClassLoader，默认是AppClassLoader。并且子线程默认使用父线程的ClassLoader除非子线程特别设置。 我们同样可以编写代码来加深理解。 现在有2个SpeakTest.class文件，一个源码是 ```javapackage com.frank.test;public class SpeakTest implements ISpeak &#123; @Override public void speak() &#123; // TODO Auto-generated method stub System.out.println(&quot;Test&quot;); &#125;&#125; 它生成的SpeakTest.class文件放置在12345678 另外ISpeak.java代码 ```java package com.frank.test;public interface ISpeak &#123; public void speak();&#125; 然后，我们在这里还实现了一个SpeakTest.java1234567891011package com.frank.test;public class SpeakTest implements ISpeak &#123; @Override public void speak() &#123; // TODO Auto-generated method stub System.out.println(\"I\\' frank\"); &#125;&#125; 它生成的SpeakTest.class文件放置在12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273然后我们还要编写另外一个ClassLoader，DiskClassLoader1.java这个ClassLoader的代码和DiskClassLoader.java代码一致，我们要在DiskClassLoader1中加载位置于```D:\\\\lib\\\\test```中的SpeakTest.class文件。测试代码：```javaDiskClassLoader1 diskLoader1 = new DiskClassLoader1(&quot;D:\\\\lib\\\\test&quot;);Class cls1 = null;try &#123;//加载class文件 cls1 = diskLoader1.loadClass(&quot;com.frank.test.SpeakTest&quot;);System.out.println(cls1.getClassLoader().toString());if(cls1 != null)&#123; try &#123; Object obj = cls1.newInstance(); //SpeakTest1 speak = (SpeakTest1) obj; //speak.speak(); Method method = cls1.getDeclaredMethod(&quot;speak&quot;,null); //通过反射调用Test类的speak方法 method.invoke(obj, null); &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;&#125; catch (ClassNotFoundException e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125; DiskClassLoader diskLoader = new DiskClassLoader(&quot;D:\\\\lib&quot;);System.out.println(&quot;Thread &quot;+Thread.currentThread().getName()+&quot; classloader: &quot;+Thread.currentThread().getContextClassLoader().toString());new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;Thread &quot;+Thread.currentThread().getName()+&quot; classloader: &quot;+Thread.currentThread().getContextClassLoader().toString()); // TODO Auto-generated method stub try &#123; //加载class文件 // Thread.currentThread().setContextClassLoader(diskLoader); //Class c = diskLoader.loadClass(&quot;com.frank.test.SpeakTest&quot;); ClassLoader cl = Thread.currentThread().getContextClassLoader(); Class c = cl.loadClass(&quot;com.frank.test.SpeakTest&quot;); // Class c = Class.forName(&quot;com.frank.test.SpeakTest&quot;); System.out.println(c.getClassLoader().toString()); if(c != null)&#123; try &#123; Object obj = c.newInstance(); //SpeakTest1 speak = (SpeakTest1) obj; //speak.speak(); Method method = c.getDeclaredMethod(&quot;speak&quot;,null); //通过反射调用Test类的say方法 method.invoke(obj, null); &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;).start(); 结果如下： 我们可以得到如下的信息： DiskClassLoader1加载成功了SpeakTest.class文件并执行成功。 子线程的ContextClassLoader是AppClassLoader。 AppClassLoader加载不了父线程当中已经加载的SpeakTest.class内容。 我们修改一下代码，在子线程开头处加上这么一句内容。1Thread.currentThread().setContextClassLoader(diskLoader1); 结果如下： 可以看到子线程的ContextClassLoader变成了DiskClassLoader。 继续改动代码：1Thread.currentThread().setContextClassLoader(diskLoader); 结果： 可以看到DiskClassLoader1和DiskClassLoader分别加载了自己路径下的SpeakTest.class文件，并且它们的类名是一样的com.frank.test.SpeakTest，但是执行结果不一样，因为它们的实际内容不一样。 Context ClassLoader的运用时机其实这个我也不是很清楚，我的主业是Android，研究ClassLoader也是为了更好的研究Android。网上的答案说是适应那些Web服务框架软件如Tomcat等。主要为了加载不同的APP，因为加载器不一样，同一份class文件加载后生成的类是不相等的。如果有同学想多了解更多的细节，请自行查阅相关资料。 总结 ClassLoader用来加载class文件的。 系统内置的ClassLoader通过双亲委托来加载指定路径下的class和资源。 可以自定义ClassLoader一般覆盖findClass()方法。 ContextClassLoader与线程相关，可以获取和设置，可以绕过双亲委托的机制。 下一步 你可以研究ClassLoader在Web容器内的应用了，如Tomcat。 可以尝试以这个为基础，继续学习Android中的ClassLoader机制。 引用我这篇文章写了好几天，修修改改，然后加上自己的理解。参考了下面的这些网站。 grepcode ClassLoader源码 http://blog.csdn.net/xyang81/article/details/7292380 http://blog.csdn.net/irelandken/article/details/7048817 https://docs.oracle.com/javase/7/docs/api/java/net/URLClassLoader.html","tags":[{"name":"IT","slug":"IT","permalink":"http://yoursite.com/tags/IT/"}]},{"title":"你是巨婴吗？","date":"2017-01-21T08:13:41.000Z","path":"2017/01/21/你是巨婴吗？/","text":"上个月，《罗辑思维》这款脱口秀讲了一个有趣的概念–巨婴。听完后，我倒吸了一口凉气，因为如果按照他们所讲的，放眼四周，巨婴比比皆是。所谓巨婴，并不是体形庞大的婴儿，也不是指侏儒，而是特指那些在某些方面心理素质还达不到标准的成年人，是的你没有看错，巨婴指的就是某类成年人，这类人的为人处事的方式、世界观、价值观极为不成熟，甚至带有强烈的婴儿期特征。我们可以回想，是不是有时候在讨论具体某个朋友的时候，身旁的人会长叹一声–“xxx都这么大了，还像个小孩子一样。”。心理专家有种说法，人的人格在六岁左右形成，而之后所有的行为都只是六岁之前的强迫性重复。所以有时研究某个人不可思议的行为时，通常有效的方法是调查他们在儿童时代遭遇和经历过什么。我相信我们都有这样的一种体验，很小的时候，别人的有意无意的一句话一些举动，会深深刻在记忆中，对自己影响至今。说这个的目的是说明，人的认知和行为方式的养成很大程序上会受到幼时成长过程的影响的。那么，研究婴儿期的行为模式和各个阶段，对研究生理条件成熟的成年人的不成熟行为提供了一些参考。那么婴儿有哪些重要的成长阶段呢？有人概括了这么几个：母婴共体、口欲期、全能自恋、偏执分裂。 母婴共体婴儿刚出生的时候，它是没有世界观的，它的意识是混沌的，它的吃喝等的所有行为都要在母亲的帮助下才能进行，它不知道世界与自我的边界，它和母体是连在一起的，这是所有人的生长的第一步，这一阶段大概是出生开始到六个月的时候。一般的人会成长到下一个阶段。但是，如果一个人到成年的时候还明显保留着这种特质，那会发生什么？但现实生活中，啃老族也并非个例，有的成年人安于现状，不思进取，每天得过且过，没有半点责任和担当,所有的消费开支甚至包括儿女的教育和成长仍然要父母一手操办。这类人似乎丧失了行动能力，就如同婴儿期一样，吃喝拉撒全都要依靠父母，这类人当然可以称之为巨婴。 口欲期想必这个名词很多人比较熟悉。是的，婴儿在早期通过嘴巴来感知世界，连接世界。也就是通过吃来让自己获取一种幸福的感受。我们经常可以看到，婴儿刚刚还哭哭啼啼的厉害，只要给奶喝马上安静和安详，喝饱后还久久不愿离开。而口欲期的消退却因人而异，有的小孩甚至上学时还喜欢啃铅笔，啃橡皮。而有些成年人表现此类特征是成天的口嚼槟榔，抽烟，喝酒，并不是说抽烟喝酒嚼槟榔都是因为口欲期，是有的成年人并非真正喜欢这些东西，他们喜欢嘴巴里面有东西的感受，没有就难受，在湖南，在我成长的过程中，见过太多同龄人因为天天嚼槟榔而导致口腔纤维化，嘴巴的肌肉都变硬无力了，还是停不下来。当然，也有些女生天天想着减肥，但是嘴上就是停不下来，而且是一天到晚不停歇。以前我们总认为他们是嘴馋或者是上瘾。其实也许，并不是食物的美味让他们嘴馋或者是香烟的尼古丁让他们上瘾，而是他们身上保留太浓烈的口欲期特性让它们对吃这个动作有着强烈的依赖。 全能自恋这也是婴儿早期的的一种意识或者说心理吧。如果说母婴共体阶段婴儿意识不到世界与自我的边界，那么这个阶段的话，婴儿是可以意识到自我的，并且只有一个我。在这个阶段，婴儿觉得世界就是我，我就是世界。也就是所谓的全能自恋了。婴儿饿了，只要“哇”地哭一声，马上就有奶喝。尿了不舒服了，只要哭一声，尿布马上换掉。整个世界的感觉好像就是任由自己呼之即来，挥之即去。但如果一个成年人还强烈地渴望追求这种感觉，也就是人常说的“世界以我为中心”，一切按自己的想法办事，不能听取别人的意见，不能和身边的人友好相处，经常弄得事情好糟糕，大家都不愉快，对于这类人那也就不得不说他心理结构不成熟，是个婴儿。 偏执分裂等婴儿意识到，它并不是世界中心的时候，它就来到了下个阶段。这个阶段，它的意识是二元化的，它看待事物只有两种结果，好的和坏的。也就是人说的，这个世界只有黑白，没有中间的灰。具体表现是婴儿喜欢某件事物时会很身心投入其中，比如玩耍一个皮球，婴儿可以表现出强烈的兴趣爱好，乐此不疲。而一旦感受到不快乐时，比如正在玩耍的皮球丢掉了或者被旁人拿开了，婴儿会立即崩溃，以嚎啕大哭的方式来抗议心中的不满。事物只有两种状态，好的坏的。好的时候，世界美好，坏的时候，就自我毁灭状。但现实生活往往是多元的，很多时候没有一个明确的答案或者是结论。网易新闻某些争议性话题中，打开评论区，有些网友的言论真的是不堪入目。或者是平常生活中，总有些人看另外一些人不顺眼，然后处处为难，真正个中的原因却很简单–你想法与我不一样，你行为方式与我不一样。就如同婴儿对待事物一样，如果认同了，那一切还好，如果不一致，也么自我毁灭吧，也就是让自己不开心，怨声载道，如果不想让自己不自在，不想让自己崩溃毁灭，那就让别人不自在，设法让别人崩溃毁灭以达到平衡自己心理感受的目的，总之这类人的心理不成熟在于无法接受不一致的观点或者是行为方法。 讲到这里的时候，我自己都比较害怕，上面的这些特征或多或少都是有的。但转眼又想一想，这些并非是生理上的不可逆转的伤害，而更多是心理结构上的不协调，都是些心理上的极端变化。我们所做的也不难，严格控制自己，提高自己做事的执行力，学习包容和接受他人不一致的观点，这样我们工作才会更有效，生活也会更轻松，心理也会更加成熟。我们应该时常认清自我，不让自己成为一个巨婴。","tags":[]},{"title":"Hello World","date":"2017-01-17T14:04:46.082Z","path":"2017/01/17/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"-test","slug":"test","permalink":"http://yoursite.com/tags/test/"}]}]